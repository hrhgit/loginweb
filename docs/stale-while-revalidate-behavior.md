# Stale-While-Revalidate Behavior in Vue Query

## 概述

本文档描述了Vue Query在队伍和作品数据缓存中实现的stale-while-revalidate行为。这种策略确保用户能够立即看到缓存数据，同时在必要时获取最新数据。

## 配置详情

### 缓存策略配置

```typescript
{
  staleTime: 1000 * 30,           // 30秒 - 数据新鲜度时间
  gcTime: 1000 * 60 * 15,         // 15分钟 - 垃圾回收时间
  refetchOnMount: false,          // 挂载时不自动重新获取
  refetchOnWindowFocus: false,    // 窗口焦点时不自动重新获取
  refetchOnReconnect: true,       // 网络重连时直接重新获取
}
```

## 请求触发策略

### 直接发起请求的情况（无条件）

1. **首次打开界面**
   - 没有缓存数据
   - 必须发起请求获取初始数据

2. **手动刷新页面**（F5 / Ctrl+R）
   - 浏览器缓存被清空
   - Vue Query内存缓存也被清空
   - 必须发起新请求

3. **网络重新连接**
   - 用户从离线状态恢复到在线
   - `refetchOnReconnect: true` 直接重新获取
   - 确保数据同步

4. **缓存失效**（invalidateQueries）
   - 执行创建/更新/删除操作时
   - 主动清除相关缓存
   - 强制重新获取最新数据

### 条件性请求的情况（基于缓存过期）

5. **窗口获得焦点**
   - 用户从其他标签页/应用切换回来
   - 检查缓存是否过期（30秒）
   - 过期则发起请求，未过期则显示缓存

6. **数据过期后再次访问**
   - 30秒后数据被标记为过期
   - 下次访问时检查过期状态
   - 过期则发起请求，未过期则显示缓存

7. **路由导航**
   - 从其他页面导航回到事件详情页
   - 组件重新挂载
   - 检查缓存过期状态，决定是否请求

8. **手动调用refetch()**
   - 用户点击"刷新"按钮
   - 代码中显式调用 `teams.refetch()`
   - 立即发起请求

9. **eventId参数变化**
   - 访问不同的事件
   - queryKey改变，无缓存
   - 发起新请求

## 用户体验流程

### 场景1：首次访问事件详情页

```
时间  操作              缓存状态    网络请求    UI显示
─────────────────────────────────────────────────
0秒   打开页面          无缓存      发起        Loading
2秒   数据返回          已缓存      完成        显示数据
```

### 场景2：在页面停留30秒后切换标签页再回来

```
时间  操作              缓存状态    网络请求    UI显示
─────────────────────────────────────────────────
0秒   打开页面          无缓存      发起        Loading
2秒   数据返回          已缓存      完成        显示数据
30秒  切换标签页        新鲜        无          （离开）
35秒  切换回来          已过期      发起        立即显示缓存
37秒  新数据返回        更新        完成        更新UI
```

### 场景3：手动刷新页面

```
时间  操作              缓存状态    网络请求    UI显示
─────────────────────────────────────────────────
0秒   打开页面          无缓存      发起        Loading
2秒   数据返回          已缓存      完成        显示数据
10秒  用户按F5          清空        发起        Loading
12秒  新数据返回        已缓存      完成        显示数据
```

### 场景4：网络断开后恢复

```
时间  操作              缓存状态    网络请求    UI显示
─────────────────────────────────────────────────
0秒   打开页面          无缓存      发起        Loading
2秒   数据返回          已缓存      完成        显示数据
10秒  网络断开          有缓存      无          显示缓存
15秒  网络恢复          有缓存      发起        立即显示缓存
17秒  新数据返回        更新        完成        更新UI
```

## 缓存检查决策流程

```
触发事件
  ↓
是否是直接请求情况？(1,2,4,7,8,9)
  ├─ 是 → 直接发起请求
  └─ 否 → 检查缓存
      ├─ 无缓存 → 发起请求
      └─ 有缓存 → 检查是否过期？
          ├─ 未过期(30秒内) → 显示缓存，不请求
          └─ 已过期(30秒后) → 显示缓存，发起请求
```

## 请求触发总结表

| # | 触发条件 | 直接请求 | 条件请求 | 配置项 |
|---|---------|---------|---------|--------|
| 1 | 首次打开界面 | ✅ | - | 无缓存 |
| 2 | 手动刷新页面 | ✅ | - | 缓存清空 |
| 3 | 窗口获得焦点 | - | ✅ | `refetchOnWindowFocus: false` |
| 4 | 网络重新连接 | ✅ | - | `refetchOnReconnect: true` |
| 5 | 数据过期后访问 | - | ✅ | `staleTime: 30s` |
| 6 | 路由导航回来 | - | ✅ | `refetchOnMount: false` |
| 7 | 缓存失效 | ✅ | - | `invalidateQueries()` |
| 8 | 手动调用refetch() | ✅ | - | 显式调用 |
| 9 | eventId参数变化 | ✅ | - | 新queryKey |

## 性能优化

### 缓存共享
- 相同eventId的查询会共享缓存
- 多个组件使用相同数据时不会重复请求

### 内存管理
- 15分钟后自动清理未使用的缓存
- 避免内存泄漏

### 网络优化
- 智能重试机制（仅网络错误重试）
- 指数退避延迟策略
- 避免不必要的频繁请求

## 总结

优化后的缓存策略提供了：
- ✅ 立即的缓存数据显示
- ✅ 智能的按需数据更新
- ✅ 合理的网络请求频率
- ✅ 良好的用户体验

这种配置确保了"缓存和请求两件事都要做"的需求，同时避免了过度的网络请求。用户既能立即看到内容，又能在必要时获得最新的数据。